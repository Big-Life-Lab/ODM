# -*- coding: utf-8 -*-
"""filter_rows_by_range_n_numeric.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EdSuhtIZhDYZQVPVZ8yNp2nwXx0yZgJu
"""

from typing import Tuple  # pylint: disable=import-error

from pandas.core.frame import DataFrame  # pylint: disable=import-error


def filter_range_by_numeric_vars(bracket: str, lower_limit: str, upper_limit: str, \
  intermediate_filtered_data: DataFrame, rule_is_numeric: bool, numeric_variables: list) -> Tuple[DataFrame, bool]:
  """The function filters data by the numeric variables in current rule.

  Function checks if the current rule value is of numeric type using 
  regular expression. If it is, then filters data by numeric variables
  in current rule. 
  Function returns back the dataframe with or without filter operation.

  Parameter:
      bracket(str): type of range bracket
      lower_limit(str): lower limit of the range
      upper_limit(str): upper limit of the range
      filter_val(str): single value to filter 
      intermediate_filtered_data(dataframe): data to be filtered
      rule_is_datetime(bool): bool variable checks rule value is datetime type
      rule_is_numeric(bool): bool variable checks rule value is numeric type
      rule_is_char(bool): bool variable checks rule value is string type
      datetime_variables(list): current rule variables of datetime type
      numeric_variables(list): current rule variables of numeric type
      string_variables(list): current rule variables of string type
  Returns:
      dataframe: Dataframe that is filtered if rule value is of datetime type
      bool: bool variable specifies the data type of rule
  """
  
  import csv
  import json
  import os
  import re

  import numpy as np  # pylint: disable=import-error
  import pandas as pd  # pylint: disable=import-error
  from numpy import nan  # pylint: disable=import-error
  from pandas import Timestamp  # pylint: disable=import-error

  from filter_single_value import \
      filter_single_value  # pylint: disable=import-error
  pat1 = r'(\d+/\d+/\d+)'
  pat2 = r'(\d+-\d+-\d+)'
  pat7 = r'(\d+-\d+-\d+ \d+:\d+)'
  pat8 = r'(\d+/\d+/\d+ \d+:\d+)'

  #If lower and upper limit value exist, then filter as per the range rule. 
  if lower_limit and upper_limit: 
    low_limit = None
    up_limit = None

    #HANDLING NUMERIC VALUES

    # iterate through numeric variables
    for numeric_var in numeric_variables: 
      if lower_limit.startswith('inf'): 
        rule_is_numeric = True

        # if lower limit is infinity subtract 1 from min value of that variable
        low_limit = (intermediate_filtered_data[numeric_var].min() - 1) 
        up_limit = eval(upper_limit)
      
      elif upper_limit.startswith('inf'):
        rule_is_numeric = True

        # if upper limit is infinity add 1 to the max value of that variable
        up_limit = (intermediate_filtered_data[numeric_var].max() + 1)
        low_limit = eval(lower_limit)

      else:
        rule_is_numeric = True
        low_limit = eval(lower_limit)
        up_limit = eval(upper_limit)

      if rule_is_numeric: 

        # Check for type of bracket and then accordingly filter the range value
        if bracket == '[]': 
          intermediate_filtered_data = intermediate_filtered_data.loc\
            [~(intermediate_filtered_data[numeric_var]>=low_limit) \
              | ~(intermediate_filtered_data[numeric_var]<=up_limit),:]

        elif bracket == '[)':
          intermediate_filtered_data = intermediate_filtered_data.loc\
            [~(intermediate_filtered_data[numeric_var]>=low_limit) | \
              ~(intermediate_filtered_data[numeric_var]<up_limit),:]

        elif bracket == '(]':
          intermediate_filtered_data = intermediate_filtered_data.loc\
            [~(intermediate_filtered_data[numeric_var]>low_limit) \
              | ~(intermediate_filtered_data[numeric_var]<=up_limit),:]
              
        elif bracket == '()':
          intermediate_filtered_data = intermediate_filtered_data.loc\
            [~(intermediate_filtered_data[numeric_var]>low_limit) | ~(\
              intermediate_filtered_data[numeric_var]<up_limit),:] 
  return intermediate_filtered_data, rule_is_numeric